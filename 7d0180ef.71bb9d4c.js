(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{111:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return u}));var a=n(1),o=n(6),r=(n(0),n(120)),i={title:"Security"},c={id:"security",title:"Security",description:"## Getting Started",source:"@site/docs/security.mdx",permalink:"/security",editUrl:"https://github.com/civitaslearning/embrace-sql/edit/master/docs/security.mdx",sidebar:"someSidebar",previous:{title:"SQL Modules",permalink:"/sqlmodules"},next:{title:"Configuration",permalink:"/configuration"}},l=[{value:"Getting Started",id:"getting-started",children:[]},{value:"Cryptographic Keys",id:"cryptographic-keys",children:[]},{value:"Accessing Tokens",id:"accessing-tokens",children:[]},{value:"Allow and Deny Access",id:"allow-and-deny-access",children:[]},{value:"Row Security",id:"row-security",children:[]},{value:"PostgreSQL Row Security",id:"postgresql-row-security",children:[]},{value:"SQL Security",id:"sql-security",children:[]}],s={rightToc:l};function u(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"getting-started"},"Getting Started"),Object(r.b)("p",null,"EmbraceSQL supports JWT in the ",Object(r.b)("inlineCode",{parentName:"p"},"Authorization: Bearer <token>")," header, passed in with each API call, and made available through the context without any additional work on your part."),Object(r.b)("p",null,"JWT tokens need to be decoded, and verified. EmbraceSQL supports public key signatures for verification. What it does not do -- is create or issue tokens, you get these from your identity provider."),Object(r.b)("p",null,"You can also use handlers to intercept API calls and do you own authentication and identity management if you aren't . JWT fan."),Object(r.b)("h2",{id:"cryptographic-keys"},"Cryptographic Keys"),Object(r.b)("p",null,"Configuration is file based, with keys stored as ",Object(r.b)("inlineCode",{parentName:"p"},".pem")," files. When using public key encryption, to verify a token from your identity provider, you create a ",Object(r.b)("inlineCode",{parentName:"p"},".pem")," file with the matching public key, and put it in the ",Object(r.b)("inlineCode",{parentName:"p"},"./keys")," folder. You can have multiple ",Object(r.b)("inlineCode",{parentName:"p"},".pem")," files, and EmbraceSQL will try them for you, allowing multiple key providers if needed."),Object(r.b)("p",null,"You can also use symmetric key, shared secret, encryption on JWT. Just store the secret key in a ",Object(r.b)("inlineCode",{parentName:"p"},".pem"),"."),Object(r.b)("h2",{id:"accessing-tokens"},"Accessing Tokens"),Object(r.b)("p",null,"Once a token is decoded and verified, it is added to the context as ",Object(r.b)("inlineCode",{parentName:"p"},"context.token"),", you can get all the claims from a JWT token inline in any handler. For example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript",metastring:'title="./default/things/all.sql.before.js"',title:'"./default/things/all.sql.before.js"'}),"export const before = async (context) => {\n  console.log(context.token);\n  // destructure the token if you like\n  const { sub, iat } = context.token;\n};\n")),Object(r.b)("h2",{id:"allow-and-deny-access"},"Allow and Deny Access"),Object(r.b)("p",null,"In any given handler, you can ",Object(r.b)("inlineCode",{parentName:"p"},"context.allow()")," or ",Object(r.b)("inlineCode",{parentName:"p"},"context.deny()")," access at any location in code. This sets internal state, and makes a record on the context each time it is called."),Object(r.b)("p",null,"You can pass any object you like to ",Object(r.b)("inlineCode",{parentName:"p"},"context.allow()")," and ",Object(r.b)("inlineCode",{parentName:"p"},"context.deny()"),", these passed objects are recorded and appended to an array ",Object(r.b)("inlineCode",{parentName:"p"},"context.grants[]")," that you can use in later event handlers, and as messages back to calling clients."),Object(r.b)("p",null,"OK -- here is how this works, when you call ",Object(r.b)("inlineCode",{parentName:"p"},"context.deny()"),", the current access state of the context is set to prevent any query from executing.\nWhen you call ",Object(r.b)("inlineCode",{parentName:"p"},"context.allow()"),", query execution is allowed. So rather than devise a 'security markup language', EmbraceSQL just has you decide if you want to deny or allow access inside handlers."),Object(r.b)("p",null,"To set up a secure by default system, you just create one root handler:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript",metastring:'title="./before.js"',title:'"./before.js"'}),"export const before = async (context) => {\n  context.deny({});\n};\n")),Object(r.b)("p",null,"And that is it -- no query will run. Let's further assume you have set up Google OpenID Connect to authenticate your users, and you are passing that id token in your ",Object(r.b)("inlineCode",{parentName:"p"},"Authorization: Bearer ...")," on requests to EmbraceSQL. Google tokens have an ",Object(r.b)("inlineCode",{parentName:"p"},"iss")," issuer property that EmbraceSQL uses to automatically find the matching publc key, decodes, and verifies the token. No need to store the public key in a ",Object(r.b)("inlineCode",{parentName:"p"},".pem"),", it'll happen for you with a compliance OpenID Connect provider."),Object(r.b)("p",null,"In the case that a token is valid, it is made available to your handlers. In the case that a token is not valid, it simply is not available. So checking authentication is checking for token existence."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript",metastring:'title="./all.before.js"',title:'"./all.before.js"'}),"export const before = async (context) => {\n  // a token, and from a specific domain\n  if (context.token && /.*@yourdomain.com$/.test(context.token.email)) {\n    // note you can pass 'any' object, string, array, or object with key/value\n    // here we use a string\n    context.allow(\"user from yourdomain granted\");\n  }\n  // if there is no context, or no match, we stick with the root deny\n};\n")),Object(r.b)("p",null,"This security models gives you complete control, using appliation code."),Object(r.b)("h2",{id:"row-security"},"Row Security"),Object(r.b)("p",null,"Assume you have a multi-tenant, or multi-user database and you want to limit which rows can be seen."),Object(r.b)("p",null,"One way to do this -- but you have a lot of flexibility with code and handlers, is to set up a domain tenant table, and have a tenant identifier on each row in other tables."),Object(r.b)("p",null,"Here is a sample migration:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql",metastring:'title="./migrations/default/000_multitenant.sql"',title:'"./migrations/default/000_multitenant.sql"'}),"-- SQLite style\nCREATE TABLE tenants (\n  tenant_id INTEGER PRIMARY KEY,\n  domain TEXT NOT NULL,\n  UNIQUE(domain)\n);\n\nCREATE TABLE multi_tenant_things (\n  thing_id INTEGER PRIMARY KEY,\n  thing_value TEXT NOT NULL,\n  tenant_id INTEGER NOT NULL,\n  FOREIGN KEY(tenant_id) REFERENCES tenants(tenant_id)\n)\n")),Object(r.b)("p",null,"Here is the SQL you need to make this work:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql",metastring:'title="./default/tenant.sql"',title:'"./default/tenant.sql"'}),"SELECT tenant_id WHERE domain = :domain\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql",metastring:'title="./default/my_things.sql"',title:'"./default/my_things.sql"'}),"SELECT thing_id, thing_value\nFROM multi_tenant_things\nWHERE tenant_id = :tenant_id\n")),Object(r.b)("p",null,"And some handlers, we'll limit access to known domains, and be secure by default. Remember you will need to pass a bearer token that will decode and validate. Remember that this is a root folder hook, so you only need to have this one time in your whole system."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript",metastring:'title="./before.js"',title:'"./before.js"'}),'export const before = (context) => {\n  context.deny({});\n  if (context.token) {\n    // pick off the back half of the email, and throw an exception otherwise\n    const domain = context.token.email.split("@")[1];\n    // issue a query to get the tenant\n    // and add it to the context parameters -- matching the named parameter in my_things.sql\n    // notice you don\'t need to tell it a row, or iterate rows here -- just a little convenience!\n    const tenant_id = await context.databases.default.tenant.sql({domain}).tenant_id;\n    context.parameters.tenant_id = tenant_id;\n    context.allow({ domain, tenant_id });\n  }\n};\n')),Object(r.b)("p",null,"And that is it -- now every query will be passed a ",Object(r.b)("inlineCode",{parentName:"p"},"tenant_id")," parameter, validated against a control table of known domains, authenticated by a third party OpenID Connect provider."),Object(r.b)("p",null,"What you'll need to remember to do:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Put the ",Object(r.b)("inlineCode",{parentName:"li"},":tenant_id")," in your where clauses"),Object(r.b)("li",{parentName:"ul"},"Authenticate your users with OpenID Connect"),Object(r.b)("li",{parentName:"ul"},"Pass the ",Object(r.b)("inlineCode",{parentName:"li"},"Authorization: Bearer ...")," header")),Object(r.b)("h2",{id:"postgresql-row-security"},"PostgreSQL Row Security"),Object(r.b)("p",null,"Integrating with PostgreSQL ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.postgresql.org/docs/12/ddl-rowsecurity.html"}),"row level security")," is even easier. You set your policies in SQL as specified by PostgreSQL, and all you need to do is tell EmbraceSQL who is the current user. Note that you don't need to create a database user for each possible user in PostgreSQL."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript",metastring:'title="./before.js"',title:'"./before.js"'}),'export const before = async (context) => {\n  context.deny({});\n  if (context.token) {\n    // something simple, email is the user identity\n    const current_user = context.token.email;\n    // and we will use the domain as the role\n    const domain = context.token.email.split("@")[1];\n    // let PostgreSQL know...\n    context.current_user = current_user;\n    context.role = domain;\n    context.allow({ current_user, role: domain });\n  }\n};\n')),Object(r.b)("p",null,"And that is it, EmbraceSQL will call ",Object(r.b)("inlineCode",{parentName:"p"},"SET LOCAL SESSION AUTHORIZATION ${context.current_user}")," and ",Object(r.b)("inlineCode",{parentName:"p"},"SET LOCAL ROLE ${context.role}")," for you, bridging in to the native access control concepts in PostgreSQL."),Object(r.b)("h2",{id:"sql-security"},"SQL Security"),Object(r.b)("p",null,"The database account you use for EmbraceSQL can have any access level you like, but know that if you limit access, some features may not work. For example, if you do not grant ",Object(r.b)("inlineCode",{parentName:"p"},"DELETE")," to your database account, AutoCRUD cannot delete."),Object(r.b)("p",null,"Migration support requires EmbraceSQL to create one table ",Object(r.b)("inlineCode",{parentName:"p"},"_embrace_sql_migrations_")," in each database. You can run without using migrations or schema warnings if you wish."))}u.isMDXComponent=!0},120:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=o.a.createContext({}),u=function(e){var t=o.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c({},t,{},e)),n},d=function(e){var t=u(e.components);return o.a.createElement(s.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},p=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=u(n),p=a,m=d["".concat(i,".").concat(p)]||d[p]||b[p]||r;return n?o.a.createElement(m,c({ref:t},s,{components:n})):o.a.createElement(m,c({ref:t},s))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=p;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var s=2;s<r;s++)i[s]=n[s];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);