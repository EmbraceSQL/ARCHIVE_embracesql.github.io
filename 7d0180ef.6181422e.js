(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{111:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return l}));var a=n(2),o=(n(0),n(120));const i={title:"Security"},r={id:"security",isDocsHomePage:!1,title:"Security",description:"Getting Started",source:"@site/docs/security.mdx",permalink:"/security",editUrl:"https://github.com/civitaslearning/embrace-sql/edit/master/docs/security.mdx",sidebar:"someSidebar",previous:{title:"SQL Modules",permalink:"/sqlmodules"},next:{title:"Embedded",permalink:"/embedded"}},s=[{value:"Getting Started",id:"getting-started",children:[]},{value:"Cryptographic Keys",id:"cryptographic-keys",children:[{value:"Providers with OpenID Connect",id:"providers-with-openid-connect",children:[]},{value:"Providers without OpenID Connect",id:"providers-without-openid-connect",children:[]},{value:"JSON Web Keys",id:"json-web-keys",children:[]}]},{value:"Accessing Tokens",id:"accessing-tokens",children:[]},{value:"Allow and Deny Access",id:"allow-and-deny-access",children:[]},{value:"Row Security",id:"row-security",children:[]},{value:"PostgreSQL Row Security",id:"postgresql-row-security",children:[]},{value:"SQL Security",id:"sql-security",children:[]}],c={rightToc:s};function l({components:e,...t}){return Object(o.b)("wrapper",Object(a.a)({},c,t,{components:e,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"getting-started"},"Getting Started"),Object(o.b)("p",null,"EmbraceSQL doesn't log users in itself -- it is counting on your app to do that -- and you pass along an ID Token in requests in order to establish user identity.\nYou can use any id token style, transported in any HTTP header you like, and provide your own event handler to validate a token and add to the execution context."),Object(o.b)("p",null,"However, there is an open standard that works great. OpenID Connect."),Object(o.b)("p",null,"EmbraceSQL supports OpenID Connect ID Tokens in the ",Object(o.b)("inlineCode",{parentName:"p"},"Authorization: Bearer <id_token>")," header, passed in with each API call, and made available through the context without any additional work on your part."),Object(o.b)("p",null,"JWT tokens need to be decoded, and verified. EmbraceSQL supports public key signatures for verification.\nWhat EmbraceSQL does not do -- is create or issue tokens, you get these from your identity provider."),Object(o.b)("h2",{id:"cryptographic-keys"},"Cryptographic Keys"),Object(o.b)("p",null,"OpenID connect ID Tokens are signed by Identity Providers, with the well known public providers (Google, Microsoft, etc) using public key encryption.\nWhen EmbraceSQL sees ",Object(o.b)("inlineCode",{parentName:"p"},"Authorization: Bearer <id_token>")," in an http request, either direct via ",Object(o.b)("inlineCode",{parentName:"p"},"POST")," or ",Object(o.b)("inlineCode",{parentName:"p"},"GET"),", or through a generated client library, a few things happen:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"EmbraceSQL ",Object(o.b)("em",{parentName:"li"},"decodes")," the token, resulting in a plain object of name value pairs"),Object(o.b)("li",{parentName:"ul"},"Looking in the token, EmbraceSQL finds the ",Object(o.b)("inlineCode",{parentName:"li"},"iss")," -- the issuer -- and uses OpenID Connect Discovery to fetch public keys"),Object(o.b)("li",{parentName:"ul"},"The token's signature is verified"),Object(o.b)("li",{parentName:"ul"},"If the token signature verification fails, a ",Object(o.b)("inlineCode",{parentName:"li"},"401")," status is returned, which will be an exception in generated clients"),Object(o.b)("li",{parentName:"ul"},"Expired tokens fail validation")),Object(o.b)("h3",{id:"providers-with-openid-connect"},"Providers with OpenID Connect"),Object(o.b)("p",null,"EmbraceSQL will download and cache keys for you in the ",Object(o.b)("inlineCode",{parentName:"p"},"${EMBRACE_SQL_ROOT}/.keys")," folder.\nThis speeds authentication and verification by eliminating any need to go out over the network."),Object(o.b)("h3",{id:"providers-without-openid-connect"},"Providers without OpenID Connect"),Object(o.b)("p",null,"Some providers don't yet support OpenID Connect, so you can supply your own copies of public keys.\nYou will need to get the provider's JSON Web Keys, which are JSON files with the keys stored encoded."),Object(o.b)("h3",{id:"json-web-keys"},"JSON Web Keys"),Object(o.b)("p",null,"Configuration is file based, with keys stored as JSON Web Key files in the ",Object(o.b)("inlineCode",{parentName:"p"},"${EMBRACE_SQL_ROOT}/.keys/<issuer>/<keyid>.json")," folder.\nYou can have multiple ",Object(o.b)("inlineCode",{parentName:"p"},".json")," files, and EmbraceSQL will try them for you, allowing multiple key providers if needed."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"issuer")," is a little problematic, since many issuers will have ",Object(o.b)("inlineCode",{parentName:"p"},"https://domain/")," formats, which make terrible file names.\nThat, and Google will describe their issuer as ",Object(o.b)("inlineCode",{parentName:"p"},"https://accounts.google.com/")," and ",Object(o.b)("inlineCode",{parentName:"p"},"accounts.google.com"),".\nEmbraceSQL will take the issuer, and if it parses as an URL, pull out just the host name -- and use that as the file name. So ",Object(o.b)("inlineCode",{parentName:"p"},"${EMBRACE_SQL_ROOT}/.keys/accounts.google.com/b16de1b2ab0c16ac0acf662ef01f7567e544252a.json")," for example."),Object(o.b)("p",null,"You can also use symmetric key, shared secret, encryption.\nJust store the secret key in a ",Object(o.b)("inlineCode",{parentName:"p"},"<issuer>/<keyid>.json"),".\nThe difference is that both you and the issuer have the same secret, so don't lose it!"),Object(o.b)("h2",{id:"accessing-tokens"},"Accessing Tokens"),Object(o.b)("p",null,"Once a token is decoded and verified, it is added to the context as ",Object(o.b)("inlineCode",{parentName:"p"},"context.token"),", you can get all the claims from a JWT token inline in any handler.\nThis is the complete, original token, decoded from JSON into an object, with all fields available."),Object(o.b)("p",null,"For example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript",metastring:'title="${EMBRACE_SQL_ROOT}/default/things/all.sql.before.js"',title:'"${EMBRACE_SQL_ROOT}/default/things/all.sql.before.js"'}),"export const before = async (context) => {\n  // destructure the token if you like\n  const { sub, iat } = context.token;\n  console.log(sub, iat);\n};\n")),Object(o.b)("h2",{id:"allow-and-deny-access"},"Allow and Deny Access"),Object(o.b)("p",null,"In any given handler, you can ",Object(o.b)("inlineCode",{parentName:"p"},"context.allow()")," or ",Object(o.b)("inlineCode",{parentName:"p"},"context.deny()")," access at any location in code."),Object(o.b)("p",null,"You can pass any object you like to ",Object(o.b)("inlineCode",{parentName:"p"},"context.allow()")," and ",Object(o.b)("inlineCode",{parentName:"p"},"context.deny()"),", these passed objects are recorded and appended to an array ",Object(o.b)("inlineCode",{parentName:"p"},"context.grants[]")," that you can use in later event handlers, and as messages back to calling clients."),Object(o.b)("p",null,"OK -- here is how this works, when you call ",Object(o.b)("inlineCode",{parentName:"p"},"context.deny()"),", the current access state of the context is set to prevent any query from executing."),Object(o.b)("p",null,"When you call ",Object(o.b)("inlineCode",{parentName:"p"},"context.allow()"),", query execution is allowed."),Object(o.b)("p",null,"So rather than devise a 'security markup language', EmbraceSQL just has you decide if you want to deny or allow access inside handlers, with real code, so you don't need to learn yet another security markup language."),Object(o.b)("p",null,"To set up a secure by default system, you just create one root handler:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript",metastring:'title="${EMBRACE_SQL_ROOT}/before.js"',title:'"${EMBRACE_SQL_ROOT}/before.js"'}),"export const before = async (context) => {\n  context.deny();\n};\n")),Object(o.b)("p",null,"And that is it -- no query will run.\nLet's further assume you have set up Google OpenID Connect to authenticate your users, and you are passing that id token in your ",Object(o.b)("inlineCode",{parentName:"p"},"Authorization: Bearer ...")," on requests to EmbraceSQL.\nGoogle tokens have an ",Object(o.b)("inlineCode",{parentName:"p"},"iss")," issuer property that EmbraceSQL uses to automatically find the matching publc key, decodes, and verifies the token.\nNo need to store the public key in a ",Object(o.b)("inlineCode",{parentName:"p"},".pem"),", it'll happen for you with a compliance OpenID Connect provider."),Object(o.b)("p",null,"In the case that a token is valid, it is made available to your handlers.\nIn the case that a token is invalid, ",Object(o.b)("inlineCode",{parentName:"p"},"403")," is returned.\nIn the case that a token is not supplied, it simply is not available.\nSo checking authentication is checking for token existence."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript",metastring:'title="${EMBRACE_SQL_ROOT}/all.before.js"',title:'"${EMBRACE_SQL_ROOT}/all.before.js"'}),"export const before = async (context) => {\n  // a token from a public provider, validate the email domain\n  // this would be an approach if you were using Google Cloud or Azure Active Directory\n  if (context.token && /.*@yourdomain.com$/.test(context.token.email)) {\n    // note you can pass 'any' object, string, array, or object with key/value\n    // here we use a string\n    context.allow(\"user from yourdomain granted\");\n  }\n  // if there is no context, or no match, we stick with the root deny\n};\n")),Object(o.b)("h2",{id:"row-security"},"Row Security"),Object(o.b)("p",null,"Assume you have a multi-tenant, or multi-user database and you want to limit which rows can be seen."),Object(o.b)("p",null,"One way to do this -- but you have a lot of flexibility with code and handlers, is to set up a domain tenant table, and have a tenant identifier on each row in other tables."),Object(o.b)("p",null,"Here is a sample migration:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql",metastring:'title="${EMBRACE_SQL_ROOT}/migrations/default/000_multitenant.sql"',title:'"${EMBRACE_SQL_ROOT}/migrations/default/000_multitenant.sql"'}),"-- SQLite style\nCREATE TABLE tenants (\n  tenant_id INTEGER PRIMARY KEY,\n  domain TEXT NOT NULL,\n  UNIQUE(domain)\n);\n\nCREATE TABLE multi_tenant_things (\n  thing_id INTEGER PRIMARY KEY,\n  thing_value TEXT NOT NULL,\n  tenant_id INTEGER NOT NULL,\n  FOREIGN KEY(tenant_id) REFERENCES tenants(tenant_id)\n)\n")),Object(o.b)("p",null,"Here is the SQL you need to make this work:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql",metastring:'title="${EMBRACE_SQL_ROOT}/default/tenant.sql"',title:'"${EMBRACE_SQL_ROOT}/default/tenant.sql"'}),"SELECT tenant_id WHERE domain = :domain\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sql",metastring:'title="${EMBRACE_SQL_ROOT}/default/my_things.sql"',title:'"${EMBRACE_SQL_ROOT}/default/my_things.sql"'}),"SELECT thing_id, thing_value\nFROM multi_tenant_things\nWHERE tenant_id = :tenant_id\n")),Object(o.b)("p",null,"And some handlers, we'll limit access to known domains, and be secure by default.\nRemember you will need to pass a bearer token that will decode and validate.\nRemember that this is a root folder handler, so you only need to have this one time in your whole system."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript",metastring:'title="${EMBRACE_SQL_ROOT}/before.js"',title:'"${EMBRACE_SQL_ROOT}/before.js"'}),'export const before = (context) => {\n  // secure by default, nobody can query\n  context.deny({});\n  // but if there is a token\n  if (context.token) {\n    // pick off the back half of the email, and throw an exception otherwise\n    const domain = context.token.email.split("@")[1];\n    // issue a query to get the tenant\n    // and add it to the context parameters -- matching the named parameter in my_things.sql\n    // notice you don\'t need to tell it a row, or iterate rows here -- just a little convenience!\n    const tenant_id = await context.databases.default.tenant({domain}).tenant_id;\n    context.parameters.tenant_id = tenant_id;\n    context.allow({ domain, tenant_id });\n  }\n};\n')),Object(o.b)("p",null,"And that is it -- now every query will be passed a ",Object(o.b)("inlineCode",{parentName:"p"},"tenant_id")," parameter, validated against a control table of known domains, authenticated by a third party OpenID Connect provider."),Object(o.b)("p",null,"What you'll need to remember to do:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Put the ",Object(o.b)("inlineCode",{parentName:"li"},":tenant_id")," in your where clauses"),Object(o.b)("li",{parentName:"ul"},"Authenticate your users with OpenID Connect"),Object(o.b)("li",{parentName:"ul"},"Pass the ",Object(o.b)("inlineCode",{parentName:"li"},"Authorization: Bearer ...")," header")),Object(o.b)("h2",{id:"postgresql-row-security"},"PostgreSQL Row Security"),Object(o.b)("p",null,"Integrating with PostgreSQL ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.postgresql.org/docs/12/ddl-rowsecurity.html"}),"row level security")," is even easier.\nYou set your policies in SQL as specified by PostgreSQL, and all you need to do is tell EmbraceSQL who is the current user.\nNote that you don't need to create a database user for each possible user in PostgreSQL."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript",metastring:'title="./before.js"',title:'"./before.js"'}),'export const before = async (context) => {\n  // secure by default, no queries allowed\n  context.deny({});\n  if (context.token) {\n    // something simple, email is the user identity\n    const current_user = context.token.email;\n    // and we will use the domain as the role\n    const domain = context.token.email.split("@")[1];\n    // let PostgreSQL know -- EmbraceSQL looks in current_user and role\n    // and adds those to the database query request\n    context.current_user = current_user;\n    context.role = domain;\n    context.allow({ current_user, role: domain });\n  }\n};\n')),Object(o.b)("p",null,"And that is it, EmbraceSQL will call ",Object(o.b)("inlineCode",{parentName:"p"},"SET LOCAL SESSION AUTHORIZATION ${context.current_user}")," and ",Object(o.b)("inlineCode",{parentName:"p"},"SET LOCAL ROLE ${context.role}")," for you, bridging in to the native access control concepts in PostgreSQL."),Object(o.b)("h2",{id:"sql-security"},"SQL Security"),Object(o.b)("p",null,"The database account you use for EmbraceSQL can have any access level you like, but know that if you limit access, some features may not work.\nFor example, if you do not grant ",Object(o.b)("inlineCode",{parentName:"p"},"DELETE")," to your database account, AutoCRUD cannot delete."),Object(o.b)("p",null,"Migration support requires EmbraceSQL to create one table ",Object(o.b)("inlineCode",{parentName:"p"},"_embrace_sql_migrations_")," in each database."))}l.isMDXComponent=!0},120:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var a=n(0),o=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),d=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=d(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},p=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=d(n),p=a,h=u["".concat(r,".").concat(p)]||u[p]||b[p]||i;return n?o.a.createElement(h,s(s({ref:t},l),{},{components:n})):o.a.createElement(h,s({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var l=2;l<i;l++)r[l]=n[l];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);